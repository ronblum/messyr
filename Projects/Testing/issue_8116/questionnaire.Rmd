---
title: "Questionnaire"
output_yaml: config/output.yaml
editor_options:
  chunk_output_type: console
---

```{r, setup, include = FALSE, cache = FALSE}
# set publication type
options(fa.publication = "questionnaire")

# initialize workspace
source(file = paste0(getOption("path.repo.fa.fokus_aargau"), ifelse(is.null(getOption("path.repo.fa.fokus_aargau")), "", "/"),
                     "r_scripts/autogenerated/fokus_aargau_initialization.R"),
       encoding = "UTF-8",
       echo = FALSE)
```

```{r, define-functions, include = FALSE}
# define functions
## generate `data/fokus_aargau_questionnaire_YYYY-MM-DD.rds`
gen_questionnaire <- function() {
  
  # initialize across-block item enumerator
  item_enumerator <- 1L
  
  # assemble questionnaire
  questionnaire <-
    purrr::map_dfr(.x = names(data_questionnaire),
                   .f = function(block) {
                     
                     # determine item enumeration prefix
                     prefix <- purrr::pluck(.x = data_questionnaire,
                                            block, "prefix",
                                            .default = 0L)
                     
                     # determine item enumeration start
                     item_enumeration_start <- ifelse(prefix == 0,
                                                      item_enumerator,
                                                      1L)
                     
                     # traverse list `data_questionnaire` recursively and assemble items
                     questionnaire <-
                       assemble_deep(data_q = data_questionnaire[[block]],
                                     devisable_map = initialize_devisable_map(),
                                     generate_md = FALSE)
                     
                     # only proceed if it is an actual questionnaire block (i.e. contains table items)
                     if ( length(questionnaire) > 0 )
                     {
                       questionnaire %<>%
                         # "unpack" results list
                         reduce_df_list() %>%
                         # add item enumeration
                         dplyr::mutate(nr = seq(from = item_enumeration_start + prefix,
                                                to = item_enumeration_start + prefix + nrow(.) - 1L,
                                                by = 1L)) %>%
                         dplyr::select(nr, tidyselect::everything())
                       
                       # update item enumerator
                       if ( prefix == 0 ) item_enumerator <<- item_enumerator + nrow(questionnaire)
                       
                     } else questionnaire <- NULL
                     
                     questionnaire
                   })
  
  questionnaire
}

## generate all blocks for Markdown questionnaire
gen_blocks <- function()
{
  # initialize block enumerator
  block_enumerator <- 1L
  
  # initialize across-block item enumerator
  item_enumerator <- 1L
  
  # traverse list `data_questionnaire` recursively to assemble questionnaire
  purrr::map(.x = names(data_questionnaire),
             .f = function(block)
             {
               # determine item enumeration prefix
               prefix <- purrr::pluck(.x = data_questionnaire,
                                      block, "prefix",
                                      .default = 0L)
               
               # determine item enumeration start
               item_enumeration_start <- ifelse(prefix == 0,
                                                item_enumerator,
                                                1L)
               
               # generate table body
               table_body <- gen_table_body(block = block,
                                            enumeration_start = item_enumeration_start)
               
               # only proceed if it is an actual questionnaire block (i.e. contains table items)
               if ( length(table_body) > 0 )
               {
                 # update item enumerator
                 if ( prefix == 0 ) item_enumerator <<- item_enumerator + length(table_body)
                 
                 # determine block "number"
                 block_nr <-
                   data_questionnaire %>%
                   purrr::pluck(block, "nr") %>%
                   glue::glue(.trim = FALSE)
                 
                 # handle auto-enumeration
                 if ( length(block_nr) == 0 )
                 {
                   block_nr <- block_enumerator
                   block_enumerator <<- block_enumerator + 1L
                 }
                 
                 # assemble block header
                 whole_block <-
                   purrr::pluck(data_questionnaire,
                                block, "title") %>%
                   glue::glue(.trim = FALSE) %>%
                   purrr::when(is.null(.) ~ "",
                               ~ paste0(": ", .)) %>%
                   paste0("## Block ", block_nr, ., "\n")
                 
                 # add block intro and table
                 whole_block <-
                   purrr::pluck(data_questionnaire,
                                block, "intro") %>%
                   pick_right() %>%
                   purrr::when(is.null(.) ~ character(0),
                               ~ glue::glue(., "\n",
                                            .trim = FALSE)) %>%
                   c(whole_block,
                     .,
                     gen_table_header(),
                     table_body) %>%
                   paste0(collapse = "\n") %>%
                   paste0("\n\n")
                 
                 return(whole_block)
                 
               } else return(NULL)
             }) %>%
    purrr::flatten_chr() %>%
    cat(sep = "\n")
  
  # assemble footnotes
  data_questionnaire$footnote %>%
    purrr::map(.f = assemble_md_ref_item) %>%
    purrr::flatten_chr() %>%
    cat("",
        sep = "\n\n")
  
  # assemble reference-style links
  data_questionnaire$link %>%
    purrr::map(.f = assemble_md_ref_item) %>%
    purrr::flatten_chr() %>%
    cat("",
        sep = "\n\n")
}

## assemble a footnote or reference-style link for Markdown questionnaire
assemble_md_ref_item <- function(l)
{
  # avoid partial matching
  l %<>% xfun::as_strict_list()
  
  if ( "id" %in% names(l)
       & ("text" %in% names(l) | "url" %in% names(l)) )
  {
    l$include %<>%
      pick_right() %>%
      dplyr::if_else(is.null(.), TRUE, .)
    
    # return NULL if item isn't included @ ballot date
    if ( !l$include )
    {
      return(NULL)
      
    } else
    {
      # determine if item is footnote or reference-style link
      is_footnote <- "text" %in% names(l)
      has_title <- !is_footnote & "title" %in% names(l)
      value <- dplyr::if_else(is_footnote,
                              "text",
                              "url")
      
      return(paste0("[",
                    dplyr::if_else(is_footnote,
                                   "^",
                                   ""),
                    glue::glue(l$id,
                               .trim = FALSE),
                    "]: ",
                    glue::glue(l[[value]],
                               .trim = FALSE),
                    dplyr::if_else(has_title,
                                   paste0(" '", l$title, "'"),
                                   "")))
    }
  } else
  {
    stop(style_error(paste0(
      "At least one of the keys ", bgGrey("id"), ", ", bgGrey("text"), "/", bgGrey("url"), " is missing from this reference item!"
    )), call. = FALSE)
  }
}

## generate table header for Markdown questionnaire
gen_table_header <- function()
{
  tibble::tribble(
    ~name,                                    ~width, ~alignment,
    "\\#",                                    2L,     "left",
    "Thema",                                  5L,     "left",
    "Wer",                                    3L,     "left",
    "Frage",                                  15L,    "left",
    "Mehrfachnennungen",                      3L,     "left",
    "Variablenname",                          5L,     "left",
    "Variablenname (gekürzt auf 32 Zeichen)", 5L,     "left",
    "Variablenlabel",                         15L,    "left",
    "Antwortoptionen",                        5L,     "left",
    "Variablenausprägungen",                  5L,     "left",
    "Ausprägungslabels",                      5L,     "left",
    "Antwortoptionen in Zufallsreihenfolge",  3L,     "left"
  ) %>%
    dplyr::mutate(separator =
                    purrr::map2_chr(.x = width,
                                    .y = alignment,
                                    .f = ~
                                      rep(x = "-",
                                          times = .x) %>%
                                      paste0(collapse = "") %>%
                                      purrr::when(.y == "left" ~ stringr::str_replace(string = .,
                                                                                      pattern = "^.",
                                                                                      replacement = ":"),
                                                  .y == "right" ~ stringr::str_replace(string = .,
                                                                                       pattern = ".$",
                                                                                       replacement = ":"),
                                                  .y == "center" ~ stringr::str_replace_all(string = .,
                                                                                            pattern = "(^.|.$)",
                                                                                            replacement = ":"),
                                                  ~ .))) %$%
    c(paste0(name, collapse = " | "),
      paste0(separator, collapse = " | "))
}

## generate table body for Markdown questionnaire
gen_table_body <- function(block,
                           enumeration_start = 1L)
{
  # ensure `block` exists
  ensure_block_exists(block = block)
  
  # traverse list `data_questionnaire` recursively to assemble questionnaire body
  body <- assemble_deep(data_q = data_questionnaire[[block]],
                        devisable_map = initialize_devisable_map())
  
  if ( length(body) > 0 )
  {
    # "unpack" results list
    while( purrr::vec_depth(body) > 2 )
    {
      body %<>% purrr::flatten()
    }
    body %<>% purrr::flatten_chr()
    
    # get block enumeration prefix
    prefix <- purrr::pluck(.x = data_questionnaire,
                           block, "prefix",
                           .default = 0L)
    
    # enumerate body rows
    body %<>% paste(seq(from = enumeration_start + prefix,
                        to = enumeration_start + prefix + length(.) - 1L,
                        by = 1L), .,
                    sep = " | ")
    
  } else body <- NULL
  
  return(body)
}

ensure_block_exists <- function(block)
{
  if ( is.null(data_questionnaire[[block]]) )
  {
    stop(style_error(paste0(
      "The block ", style_arg_invalid(block), " doesn't exist in ", style_v_name("data_questionnaire"), "!"
    )), call. = FALSE)
  }
}

## initialize devisable map of key-value pairs that can be valid for multiple questions (set hierarchically)
initialize_devisable_map <- function()
{
  xfun::strict_list(i = NULL,
                    j = NULL,
                    topic = NULL,
                    who = NULL,
                    question = NULL,
                    question_common = NULL,
                    multiple_answers_allowed = FALSE,
                    variable_label = NULL,
                    variable_label_common = NULL,
                    response_options = NULL,
                    variable_values = NULL,
                    value_labels = NULL,
                    value_scale = "nominal",
                    randomize_response_options = FALSE,
                    ballot_type = "both_referendum_and_election",
                    include = TRUE)
}

## traverse questionnaire recursively and assemble questionnaire block
## default is to generate Markdown table rows (strings); if `generate_md = FALSE`, a tibble will be returned instead.
assemble_deep <- function(data_q,
                          devisable_map,
                          generate_md = TRUE) {
  
  devisable_map %<>% complement_devisable(from = data_q)
  result <- NULL
  
  if ("variable_name" %in% names(data_q)) {
    
    result <- process_item(v_name = data_q$variable_name,
                           devisable_map = devisable_map,
                           generate_md = generate_md)
    
  } else if (purrr::vec_depth(data_q) > 2) {
    
    result <-
      data_q %>%
      purrr::map(.f = assemble_deep,
                 devisable_map = devisable_map,
                 generate_md = generate_md) %>%
      purrr::compact()
    
  }
  
  result
}

## complement `map` with key-values from top level of list
complement_devisable <- function(map,
                                 from)
{
  names <- names(map)
  
  map %>%
    purrr::map2(.x = names,
                .y = .,
                .f = function(k, v) purrr::pluck(.x = from,
                                                 k,
                                                 .default = v)) %>%
    magrittr::set_names(names)
}

## process an "atomic" questionnaire item
process_item <- function(v_name,
                         devisable_map,
                         generate_md = TRUE)
{
  # ensure nothing indispensable is missing
  check_devisable_map_completeness(devisable_map = devisable_map)
  
  # choose correct include iterator and keys
  devisable_map[["include"]] %<>% pick_right()
  devisable_map[["ballot_type"]] %<>% pick_right()
  devisable_map[["i"]] %<>% pick_right()
  devisable_map[["j"]] %<>% pick_right()
  
  # return NULL if item isn't included @ ballot date
  if ( !devisable_map[["include"]]
       | (devisable_map$ballot_type != "both_referendum_and_election" & devisable_map$ballot_type != fa_ballot_type()) )
  {
    return(NULL)
    
  } else
  {
    # evaluate 1st-level iterator and also return NULL if `i` is defined but evaluates to NULL (which means item isn't included @ ballot date)
    # NOTE: we need to handle the value `""` separately because it would evaluate to NULL when parsed
    if ( isTRUE(devisable_map[["i"]] != "") & !is.null(devisable_map[["i"]]) )
    {
      devisable_map[["i"]] <- eval(parse(text = devisable_map[["i"]]))
      
      if ( is.null(devisable_map[["i"]]) )
      {
        return(NULL)
      }
    }
    
    # assemble "normal" questionnaire items
    if ( is.null(devisable_map[["i"]]) & is.null(devisable_map[["j"]]) )
    {
      if ( generate_md )
      {
        result <- assemble_table_row(v_name = v_name,
                                     devisable_map = devisable_map)
      } else
      {
        result <- assemble_subitem(v_name = v_name,
                                   devisable_map = devisable_map)
      }
    } else if ( is.null(devisable_map[["j"]]) )
    {
      if ( generate_md )
      {
        result <- purrr::map_chr(.x = devisable_map[["i"]],
                                 .f = assemble_table_row,
                                 v_name = v_name,
                                 devisable_map = devisable_map)
      } else
      {
        result <- purrr::map_dfr(.x = devisable_map[["i"]],
                                 .f = assemble_subitem,
                                 v_name = v_name,
                                 devisable_map = devisable_map)
      }
      
      # validity check
    } else if ( is.null(devisable_map[["i"]]) )
    {
      # this combo doesn't really make sense and should never occur
      stop(style_error(paste0(
        "This should not happen (", style_v_name("j"), " set, but ", style_v_name("i"), " ", crayon::bold("not"), " set)!"
      )), call. = FALSE)
      
      # if ( generate_md )
      # {
      #   result <- purrr::map_chr(.x = devisable_map[["j"]],
      #                            .f = assemble_table_row,
      #                            v_name = v_name,
      #                            devisable_map = devisable_map)
      # } else
      # {
      #   result <- purrr::map_dfr(.x = devisable_map[["j"]],
      #                            .f = assemble_subitem,
      #                            v_name = v_name,
      #                            devisable_map = devisable_map)
      # }
      
      # "template" items resulting in multiple questionnaire items
    } else
    {
      if ( generate_md )
      {
        result <-
          purrr::map(.x = devisable_map[["i"]],
                     .f = function(x)
                     {
                       i <- x
                       purrr::map_chr(i = x,
                                      .x = eval(parse(text = devisable_map[["j"]])),
                                      .f = assemble_table_row,
                                      v_name = v_name,
                                      devisable_map = devisable_map)
                     }) %>%
          purrr::flatten_chr()
        
      } else
      {
        result <-
          purrr::map_dfr(.x = devisable_map[["i"]],
                         .f = function(x)
                         {
                           i <- x
                           purrr::map_dfr(i = x,
                                          .x = eval(parse(text = devisable_map[["j"]])),
                                          .f = assemble_subitem,
                                          v_name = v_name,
                                          devisable_map = devisable_map)
                         })
      }
    }
    
    return(result)
  }
}

## check devisable map for completeness
check_devisable_map_completeness <- function(devisable_map)
{
  devisable_map_essential <-
    devisable_map %>%
    purrr::list_modify(i = rlang::zap(),
                       j = rlang::zap(),
                       topic = rlang::zap(),
                       question = rlang::zap(),
                       question_common = rlang::zap(),
                       variable_label_common = rlang::zap(),
                       response_options = rlang::zap(),
                       variable_values = rlang::zap(),
                       value_labels = rlang::zap())
  
  if ( devisable_map_essential %>%
       purrr::map_lgl(.f = is.null) %>%
       any() )
  {
    unset_keys <-
      devisable_map_essential %>%
      purrr::keep(.p = is.null) %>%
      names()
    
    rlang::abort(message = style_error(paste(
      "The key", dplyr::if_else(length(unset_keys) > 1,
                                "s",
                                NA_character_), style_arg_invalid(unset_keys), dplyr::if_else(length(unset_keys) > 1,
                                                                                              "are",
                                                                                              "is"),
      "not set for variable", style_v_name(purrr::chuck(.x = q,
                                                        "variable_name"))
    )))
  }
}

## assemble a single (or template) table body row for Markdown questionnaire
assemble_table_row <- function(i = NULL,
                               j = NULL,
                               v_name,
                               devisable_map)
{
  # parse the variable name
  v_name %<>%
    pick_right() %>%
    glue::glue(.trim = FALSE)
  
  who <-
    devisable_map %>%
    purrr::chuck("who") %>%
    pick_right() %>%
    glue::glue(.trim = FALSE)
  
  who_en <-
    data_questionnaire$who %>%
    purrr::detect(~ .x$value$de == stringr::str_replace(string = who,
                                                        pattern = "\\d+",
                                                        replacement = "{i}")) %>%
    purrr::chuck("value", "en") %>%
    glue::glue(.trim = FALSE)
  
  paste(
    # topic
    devisable_map %>%
      purrr::pluck("topic",
                   .default = "-") %>%
      pick_right() %>%
      glue::glue(.trim = FALSE,
                 .na = "-"),
    # who
    who,
    # question
    devisable_map %>%
      purrr::pluck("question",
                   .default = "-") %>%
      pick_right() %>%
      glue::glue(.trim = FALSE,
                 .na = "-"),
    # multiple answers allowed?
    devisable_map %>%
      purrr::chuck("multiple_answers_allowed") %>%
      pick_right() %>%
      glue::glue(.trim = FALSE) %>%
      as.logical() %>%
      purrr::when(isTRUE(.) ~ "ja",
                  ~ "nein"),
    # variable name
    v_name %>%
      wrap_backtick() %>%
      collapse_break(),
    # variable_name_32,
    v_name %>%
      shorten_fa_v_names() %>%
      wrap_backtick() %>%
      collapse_break(),
    # variable label
    devisable_map %>%
      purrr::chuck("variable_label") %>%
      pick_right() %>%
      glue::glue(.trim = FALSE) %>%
      add_who_constraint(who = who_en),
    # response options
    devisable_map %>%
      purrr::pluck("response_options",
                   .default = "-") %>%
      pick_right() %>%
      purrr::map(.envir = parent.frame(n = 2),
                 .f = glue::glue,
                 .trim = FALSE,
                 .na = "-") %>%
      purrr::flatten_chr() %>%
      wrap_backtick() %>%
      {
        if ( is_fa_skill_question(v_names = v_name) )
        {
          emphasize(s = .,
                    which = fa_skill_question_answer_nr(skill_question_nr = ifelse(is_fa_election(), i, j),
                                                        level = fa_v_level(v_name = v_name),
                                                        nr = i))
        } else .
      } %>%
      collapse_break(),
    # variable values
    devisable_map %>%
      purrr::pluck("variable_values",
                   .default = "-") %>%
      pick_right() %>%
      purrr::map(.envir = parent.frame(n = 2),
                 .f = glue::glue,
                 .trim = FALSE,
                 .na = "-") %>%
      purrr::flatten_chr() %>%
      wrap_backtick() %>%
      collapse_break(),
    # value labels
    devisable_map %>%
      purrr::pluck("value_labels",
                   .default = "-") %>%
      pick_right() %>%
      purrr::map(.envir = parent.frame(n = 2),
                 .f = glue::glue,
                 .trim = FALSE,
                 .na = "-") %>%
      purrr::flatten_chr() %>%
      wrap_backtick() %>%
      collapse_break(),
    # randomize response options?
    devisable_map %>%
      purrr::chuck("randomize_response_options") %>%
      pick_right() %>%
      glue::glue(.trim = FALSE) %>%
      as.logical() %>%
      purrr::when(isTRUE(.) ~ "ja",
                  ~ "nein"),
    sep = " | "
  )
}

## assemble a single (or template) subitem for `data/fokus_aargau_questionnaire_YYYY-MM-DD.rds`
assemble_subitem <- function(i = NULL,
                             j = NULL,
                             v_name,
                             devisable_map)
{
  # parse the variable name
  v_name %<>%
    pick_right() %>%
    glue::glue(.trim = FALSE)
  
  # special case: if no `question_common` is defined, use `question.default` instead if it exists
  question <-
    devisable_map %>%
    purrr::pluck("question",
                 .default = NA_character_)
  
  question_common <-
    devisable_map %>%
    purrr::pluck("question_common",
                 .default = NA_character_) %>%
    pick_right() %>%
    glue::glue(.na = NULL,
               .trim = FALSE) %>%
    strip_md()
  
  if ( is.na(question_common) & "default" %in% names(question) )
  {
    question_common <-
      question$default %>%
      pick_right() %>%
      glue::glue(.na = NULL,
                 .trim = FALSE) %>%
      strip_md()
  }
  
  # special case: if no `variable_label_common` is defined, use `variable_label.default` instead if it exists
  variable_name <-
    v_name %>%
    strip_md()
  
  who <-
    devisable_map %>%
    purrr::chuck("who") %>%
    pick_right() %>%
    glue::glue(.trim = FALSE) %>%
    strip_md()
  
  who_en <-
    data_questionnaire$who %>%
    purrr::detect(~ .x$value$de == stringr::str_replace(string = who,
                                                        pattern = "\\d+",
                                                        replacement = "{i}")) %>%
    purrr::chuck("value", "en") %>%
    glue::glue(.trim = FALSE) %>%
    strip_md()
  
  variable_label <-
    devisable_map %>%
    purrr::chuck("variable_label")
  
  variable_label_common <-
    devisable_map %>%
    purrr::pluck("variable_label_common",
                 .default = NA_character_) %>%
    pick_right() %>%
    glue::glue(.na = NULL,
               .trim = FALSE) %>%
    strip_md()
  
  if ( is.na(variable_label_common) & "default" %in% names(variable_label) )
  {
    # integrity check: ensure there haven't been any changes to `who` over time (if so, an explcicit `variable_label_common` has to be defined!)
    if ( length(devisable_map$who) > 1 )
    {
      rlang::abort(message = style_error(paste0(
        bgGrey("who"), " of variable ", style_v_name(variable_name), " has changed over time. Thus a custom ",
        crayon::bgYellow("variable_label_common"), " must be defined in ", bgGrey("questionnaires/questionnaire.toml"), "!"
        )))
      
    } else
    {
      variable_label_common <-
        variable_label$default %>%
        pick_right() %>%
        glue::glue(.na = NULL,
                   .trim = FALSE) %>%
        strip_md() %>%
        add_who_constraint(who = who_en)
    }
    # add who constraint if necessary
  } else if ( !is.na(variable_label_common)
              & !stringr::str_detect(string = variable_label_common,
                                     pattern = "(\\(|; )only .*?\\)$") )
  {
    if ( length(devisable_map$who) > 1 )
    {
      rlang::abort(message = style_error(paste0(
        bgGrey("who"), " of variable ", style_v_name(variable_name), " has changed over time. Thus the ", bgGrey("who"), " constraint has to be explicitly ",
        "specified at the end of ", crayon::bgYellow("variable_label_common"), " in ", bgGrey("questionnaires/questionnaire.toml"), "!"
      )))
      
    } else variable_label_common %<>% add_who_constraint(who = who_en)
  }
  
  tibble::tibble(
    topic =
      devisable_map %>%
      purrr::pluck("topic",
                   .default = NA_character_) %>%
      pick_right() %>%
      glue::glue(.na = NULL,
                 .trim = FALSE) %>%
      strip_md(),
    who = who,
    question =
      question %>%
      pick_right() %>%
      glue::glue(.na = NULL,
                 .trim = FALSE) %>%
      strip_md(),
    question_common = question_common,
    multiple_answers_allowed =
      devisable_map %>%
      purrr::chuck("multiple_answers_allowed") %>%
      pick_right() %>%
      glue::glue(.trim = FALSE) %>%
      as.logical(),
    variable_name = variable_name,
    variable_name_32 =
      variable_name %>%
      shorten_fa_v_names(),
    variable_label =
      variable_label %>%
      pick_right() %>%
      glue::glue(.trim = FALSE) %>%
      strip_md() %>%
      add_who_constraint(who = who_en),
    variable_label_common = variable_label_common,
    response_options =
      devisable_map %>%
      purrr::pluck("response_options",
                   .default = NA_character_) %>%
      pick_right() %>%
      purrr::map(.f = glue::glue,
                 .envir = parent.frame(n = 2),
                 .na = NULL,
                 .trim = FALSE) %>%
      purrr::flatten_chr() %>%
      list(),
    variable_values =
      devisable_map %>%
      purrr::pluck("variable_values",
                   .default = rep(x = NA_integer_,
                                  times =
                                    purrr::pluck(.x = devisable_map,
                                                 "response_options",
                                                 .default = NA_character_) %>%
                                    pick_right() %>%
                                    purrr::map(.f = glue::glue,
                                               .envir = parent.frame(n = 2),
                                               .na = NULL,
                                               .trim = FALSE) %>%
                                    purrr::flatten_chr() %>%
                                    length())) %>%
      pick_right() %>%
      purrr::map(.f = glue::glue,
                 .envir = parent.frame(n = 2),
                 .na = NULL,
                 .trim = FALSE) %>%
      purrr::map(.f = as.integer) %>%
      purrr::flatten_int() %>%
      list(),
    value_labels =
      devisable_map %>%
      purrr::pluck("value_labels",
                   .default = NA_character_) %>%
      pick_right() %>%
      purrr::map(.f = glue::glue,
                 .envir = parent.frame(n = 2),
                 .na = NULL,
                 .trim = FALSE) %>%
      purrr::flatten_chr() %>%
      list(),
    value_scale =
      devisable_map %>%
      purrr::chuck("value_scale") %>%
      pick_right() %>%
      glue::glue(.trim = FALSE) %>%
      strip_md(),
    randomize_response_options =
      devisable_map %>%
      purrr::chuck("randomize_response_options") %>%
      pick_right() %>%
      glue::glue(.trim = FALSE) %>%
      as.logical()
  )
}

## pick the right value for the current ballot date of a certain key (recursively)
pick_right <- function(l,
                       date = fa_date())
{
  if ( purrr::vec_depth(l) < 2 )
  {
    return(l)
    
  } else
  {
    l <- pick_right_helper(l = l,
                           date = date)
    return(pick_right(l,
                      date = date))
  }
}

pick_right_helper <- function(l,
                              date)
{
  if ( purrr::is_list(l) & (length(l) > 1 | purrr::vec_depth(l) > 1) )
  {
    # create plain ballot date as in subkeys
    date_plain <- stringr::str_remove_all(string = date,
                                          pattern = "-")
    # convert ballot date to type date
    date %<>% lubridate::as_date()
    
    # handle begin-end date subkeys
    begin_end_subkeys <-
      names(l) %>%
      stringr::str_subset(pattern = "^\\d+_\\d+$")
    
    matches_begin_end_subkeys <-
      begin_end_subkeys %>%
      purrr::map_lgl(function(x)
      {
        begin <- x %>% stringr::str_extract(pattern = "^\\d+") %>% lubridate::as_date()
        end <- x %>% stringr::str_extract(pattern = "\\d+$") %>% lubridate::as_date()
        
        if ( begin <= date & date <= end ) TRUE else FALSE
      })
    
    # integrity check: ensure there aren't any overlapping intervals
    if ( length(which(matches_begin_end_subkeys)) > 1 )
    {
      rlang::abort(message = style_error(paste0(
        "Illegal overlapping interval subkeys found: ", paste0(style_arg_invalid(begin_end_subkeys[matches_begin_end_subkeys]),
                                                               collapse = ", "),
        "\nPlease fix this and run again."
      )))
    }
    
    names(l) %>%
      purrr::when(
        # consider overrides for binary keys
        date %in% l[["false"]] ~ FALSE,
        date %in% l[["true"]] ~ TRUE,
        
        # consider overrides for non-binary keys
        ## single date subkey
        date_plain %in% . ~ l[[date_plain]],
        ## begin-end date subkey
        length(which(matches_begin_end_subkeys)) > 0 ~ l[[begin_end_subkeys[matches_begin_end_subkeys]]],
        
        # consider overrides for ballot types
        fa_ballot_type() %in% . ~ l[[fa_ballot_type()]],
        
        # return default value if defined
        "default" %in% . ~ l[["default"]],
        
        # return TRUE in any remaining cases
        ~ TRUE
      )
  } else
  {
    return(l)
  }
}

## wrap a char vector in backticks
wrap_backtick <- function(s)
{
  purrr::map_chr(.x = s,
                 .f = ~ dplyr::if_else(.x == "-" | stringr::str_detect(string = .x,
                                                                       pattern = "^(_.*_|\\*.*\\*)$"),
                                       as.character(.x),
                                       paste0("`", .x, "`")))
}

## collapse char vector into single string separated by single HTML line breaks (`<br>` tags)
collapse_break <- function(s)
{
  paste0(s,
         collapse = "<br>")
}

## add the who constraint wrapped in parentheses to the end of a string (e.g. `variable_label`)
add_who_constraint <- function(s,
                               who) {
  
  if ( who != "all")
  {
    who %>%
      purrr::when(stringr::str_detect(string = s,
                                      pattern = "\\)$") ~ stringr::str_replace(string = s,
                                                                               pattern = "\\)$",
                                                                               replacement = paste0("; only ", ., ")")),
                  ~ paste0(s, " (only ", ., ")"))
  } else s
}
```

```{r, read-in-questionnaire-data, include = FALSE}
read_in_ballot_date_specific_questionnaire_data()

# read in questionnaire data
data_questionnaire <- fa_repo_path("questionnaires/questionnaire.toml") %>% read_toml()

# write parsed questionnaire data to `data/fokus_aargau_questionnaire_YYYY-MM-DD.rds`
gen_questionnaire() %>%
  readr::write_rds(path = fa_repo_path(glue::glue("data/fokus_aargau_questionnaire_{fa_date()}.rds")),
                   compress = "xz",
                   compression = 9L)
```

[_Letzte Änderung: `r fa_mod_time() %>% format("%d. %B %Y, %H:%M Uhr")`_]{.minifontsize}

## Technische Vorbemerkungen

### `Wer`

Die Spalte `Wer` dient dem Fragebogen-Routing. Sie kennt folgende Werte:

```{r, generate-who, results = "asis"}
data_questionnaire$who %>%
  purrr::map_chr(.f = function(x) {
    
    # avoid partial matching
    x %<>% xfun::as_strict_list()
    
    matches_ballot_type <-
      dplyr::if_else(is.null(x$ballot_type),
                     "both_referendum_and_election",
                     x$ballot_type) %>%
      stringr::str_detect(pattern = fa_ballot_type())
    
    include <-
      x$include %>%
      pick_right() %>%
      dplyr::if_else(is.null(.), TRUE, .)
    
    if (matches_ballot_type & include) {
      
      i <-
        x[["i"]] %>%
        pick_right() %>%
        glue::glue(.trim = FALSE) %>%
        as.integer()
      
      if (length(i) > 0L) {
        glue::glue(x$value$de,
                   .trim = FALSE) %>%
          emphasize() %>%
          purrr::map2_chr(.y = i %>% purrr::map_chr(function(i) glue::glue(x$description$de,
                                                                           .trim = FALSE)),
                          .f = ~ paste0("- ", .x, ": ", .y)) %>%
          paste0(collapse = "\n")
        
      } else {
        
        if (length(glue::glue(x$value$de,
                              .trim = FALSE)) > 0L) {
          
          glue::glue(x$value$de,
                     .trim = FALSE) %>%
            emphasize() %>%
            paste0("- ", ., ": ", glue::glue(x$description$de,
                                             .trim = FALSE))
          
        } else NA_character_
      }
    } else NA_character_
  }) %>%
  magrittr::extract(!is.na(.)) %>%
  cat(sep = "\n")
```

### `Mehrfachnennungen`

Die Spalte `Mehrfachnennungen` gibt an, ob es den Befragten möglich ist, mehrere der `Antwortoptionen` gleichzeitig auszuwählen. Obschon versucht wurde, dies tunlichst zu vermeiden, hat sich bei einigen Fragen ein solches Vorgehen als die praktikabelste Lösung herausgestellt. Die Spalte `Mehrfachnennungen` kennt die beiden folgenden Werte:

- **ja**: Mehrfachnennungen sind möglich und werden in der Analyse anteilsmässig gewichtet. Wählt eine RespondentIn also bspw. drei Antwortoptionen zugleich aus, wird jede davon zu einem Drittel gezählt, entscheidet sie sich hingegen nur für eine Antwortoption, zählt diese voll.

    Die Konvention zur Kodierung gewollter Mehrfachnennungen lautet, dass `#` einzelne Variablen benannt nach dem Schema `<VARIABLENNAME>_d#` statt der einen ursprünglichen Variable gemäss diesem Fragebogen resultieren, wobei `#` der Anzahl offerierter Antwortoptionen entspricht.

    **Beispiel:**
    
    Im Falle, dass `main_motive_cantonal_proposal_1_yes` Mehrfachnennungen erlaubt und insgesamt vier Antwortoptionen kennt, resultieren dementsprechend die folgenden vier dichotomen Variablen:
    
    1. `main_motive_cantonal_proposal_1_yes_d1`: Weist die Ausprägung `1` auf im Falle, dass die 1. Antwortoption gewählt wurde, andernfalls `0`.
    2. `main_motive_cantonal_proposal_1_yes_d2`: Weist die Ausprägung `1` auf im Falle, dass die 2. Antwortoption gewählt wurde, andernfalls `0`.
    3. `main_motive_cantonal_proposal_1_yes_d3`: Weist die Ausprägung `1` auf im Falle, dass die 3. Antwortoption gewählt wurde, andernfalls `0`.
    4. `main_motive_cantonal_proposal_1_yes_d4`: Weist die Ausprägung `1` auf im Falle, dass die 4. Antwortoption gewählt wurde, andernfalls `0`.
    
    (Im Falle, dass eine der Antwortoptionen von `main_motive_cantonal_proposal_1_yes_custom` ein [Freitextfeld](#freitextfelder) (Ausprägung `90`) vorsieht, resultiert zusätzlich noch die Variable `main_motive_cantonal_proposal_1_yes_custom`.)

- **nein**: Mehrfachnennungen sind nicht vorgesehen und den Online-Respondenten auch technisch verunmöglicht. Sollten im Print-Fragebogen Mehrfachnennungen auftreten, wird in der Analyse auf reproduzierbare, _pseudo-zufällige_ Weise eine der Nennungen ausgewählt.

    Während beim Online-Fragebogen ungewollte Mehrfachnennungen technisch verunmöglicht werden, lässt sich eine solche Einschränkung im Print-Fragebogen naturgemäss nicht durchsetzen. Dies hat im Falle ungewollter Mehrfachnennungen zur Folge, dass mehrere Variablen aus dieser Frage resultieren, deren genaue Anzahl (zumindest der nicht-leeren) allerdings nicht vorausgesagt werden kann (Maximum = Anzahl `Antwortoptionen`).
    
    Die Konvention lautet, dass der ursprünglichen Variable gemäss diesem Fragebogen bei Mehrfachnennungen der Wert `-8` zugewiesen wird und die zusätzlichen Variablen mit den konkreten Doppelnennungen nach dem Schema `<VARIABLENNAME>_d#` benannt werden.

    **Beispiel:**
    
    Bei einer maximalen Zahl von drei ungewollten Mehrfachnennungen in `employment_situation` resultieren dementsprechend die folgenden vier Variablen:
    
    1. `employment_situation`: Weist im Falle einer Mehrfachnennung die Ausprägung `-8` auf, andernfalls die "normale" Ausprägung gemäss diesem Fragebogen.
    2. `employment_situation_d1`: Weist im Falle einer Mehrfachnennung die Ausprägung der ersten gewählten `Antwortoption` auf, andernfalls keinen Wert (`NA`).
    3. `employment_situation_d2`: Weist im Falle einer Mehrfachnennung die Ausprägung der zweiten gewählten `Antwortoption` auf, andernfalls keinen Wert (`NA`).
    4. `employment_situation_d3`: Weist im Falle einer Mehrfachnennung die Ausprägung der dritten gewählten `Antwortoption` auf, andernfalls keinen Wert (`NA`).

### Freitextfelder

Sieht eine Frage als eine der Antwortoptionen ein Freitextfeld vor, so resultiert neben der ursprünglichen Variable gemäss diesem Fragebogen immer eine zusätzliche Variable `<VARIABLENNAME>_custom`, welche die entsprechenden Freitextantworten enthält.

**Beispiel:**

Die Frage zur Parteisympathie (Variablenname `favored_party`) kennt die Antwortoption `eine andere, nämlich: ✍ (Freitextfeld)`. Dementsprechend resultieren im Datensatz – sofern die Frage keine [Mehrfachnennungen](#mehrfachnennungen) erlaubt und keine ungewollten Mehrfachnennungen im Print-Fragebogen auftreten – die folgenden beiden Variablen:

1. `favored_party`: Weist die "normale" Ausprägung gemäss diesem Fragebogen auf, im Falle einer Freitextantwort also `90`.
2. `favored_party_custom`: Weist im Falle einer Freitextantwort (`favored_party = 90`) die genannte Antwort im Volltext auf, andernfalls keinen Wert (`NA`).


## Einleitung

Wir bitten Sie, den Fragebogen vollständig und ehrlich zu beantworten. Bitte beachten Sie, dass Ihre ganz persönliche Einschätzung gefragt ist und es bei vielen Fragen keine richtigen oder falschen Antworten gibt. Wenn Sie das Gefühl haben, dass keine Antwort genau auf Sie zutrifft, dann wählen Sie jeweils die passendste. Ihre Antworten werden selbstverständlich vertraulich und anonym behandelt. Wir bedanken uns im Voraus ganz herzlich für Ihre Mitarbeit!

Bitte benutzen Sie schwarzen oder blauen Kugelschreiber und kreuzen Sie die zutreffende Antwort an. Beispiel: ☒


```{r, generate-blocks, results = "asis"}
gen_blocks()
```